== general comments ==
- indentation, let's use three spaces, no tabs.
- names of states: State, printState, countState --> Let's start with a capital letter for State types: State, PrintState, CountState
- make sure you save changes and close VIM before sending files, commiting changes to the repository, otherwise we get .swp files everywhere

== main_print.lua ==
- c = printState:create{string = "Michael"}, careful, I think "string" is the name of a lua library, perhaps use "text" instead
- substate table
   - initial_state --> initial (shorter to write)
   - we current have keys a,b,c,d,etc for assigning states to. let's just use the key as the state id and remove the state_object.id variable. syntax:

   substates = {
      ["printmichael"] = PrintState{text = "Michael"},
      ["printsaid"] = PrintState{text = "said"},
   },

   - is there any advantage to holding the string inside 'initial' instead of the actual state, e.g.?
   initial = "printmichael"; --> initial = substates("printmichael");
- transitions table
   - make condition optional, e.g. so that assigning it overwrites a default function that always returns true

== State.lua ==
- function State:create(options) --> function State:create(configuration)
- state_object --> instance (correct terminology)

== CountState.lua / PrintState.lua ==
- father --> parent (correct terminology)
- does countState:method try to add a transition to its table every time it is run? I think we need to rethink how this is designed. Perhaps we just update State.current from countState:method and remove the transition table? E.g.

function countState:method(father)
	printState.method(self) -- I assume this line is just for debugging?

	parent.data.i = parent.data.i + 1 -- use parent, not father. Why do we need to use parent.data here?

   local next = nil

   if(data.i == 3) then
      next = 'b'
   end
   return next
end

== main_count.lua ==
- a = countState:create{string = "I"}, why does count state take a string?
